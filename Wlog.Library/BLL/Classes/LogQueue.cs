//******************************************************************************
// <copyright file="license.md" company="Wlog project  (https://github.com/arduosoft/wlog)">
// Copyright (c) 2016 Wlog project  (https://github.com/arduosoft/wlog)
// Wlog project is released under LGPL terms, see license.md file.
// </copyright>
// <author>Daniele Fontani, Emanuele Bucaelli</author>
// <autogenerated>true</autogenerated>
//******************************************************************************
using NHibernate;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using Wlog.DAL.NHibernate.Helpers;
using Wlog.BLL.Entities;
using Wlog.Library.BLL.Reporitories;
using Wlog.Library.BLL.Interfaces;
using Wlog.Library.BLL.DataBase;
using Wlog.Library.BLL.Classes;

namespace Wlog.BLL.Classes
{
    public class LogQueue : EntityRepository
    {
        private Queue<LogMessage> queque = new Queue<LogMessage>();
        public List<QueueLoad> QueueLoad { get; set; }

        public int MaxProcessedItems { get; set; }
        public int MaxQueueSize { get; set; }

        private static string lockObj="";

        public long Count
        {
            get { return queque.Count; }
        }

        public void Enqueue(LogMessage le)
        {
            queque.Enqueue(le);
        }

        public LogQueue()
        {
            MaxProcessedItems = 700;
            MaxQueueSize = 100000;
            QueueLoad = new List<Classes.QueueLoad>();
            AppendLoadValue(0, MaxQueueSize);
        }

        public List<LogMessage> Dequeue(int count)
        {
            List<LogMessage> result = new List<LogMessage>();
            LogMessage newElem;
            int i = 0;
            while (i < count)
            {
                newElem = queque.Dequeue();
                if (newElem != null)
                {
                    result.Add(newElem);
                }
                else
                {
                    break;
                }
                i++;
            }
            return result;
        }


        /// <summary>
        /// Process queue and update stats.
        /// It removes LogQueue.Current.MaxProcessedItems elements and save in a single transaction
        /// </summary>
        public void Run()
        {
           lock(lockObj)
            {
                //Update stats
                LogQueue.Current.AppendLoadValue(LogQueue.Current.Count, LogQueue.Current.MaxQueueSize);

                if (LogQueue.Current.Count > 0)
                {
                    List<LogEntity> logs = GetLastLogs();
                    RepositoryContext.Current.Logs.Save(logs);
                        LogQueue.Current.AppendLoadValue(LogQueue.Current.Count, LogQueue.Current.MaxQueueSize);
                }
            }
        }

        private List<LogEntity> GetLastLogs()
        {
            List<LogEntity> result = new List<LogEntity>();
            LogMessage log;
            LogEntity logE;
            Dictionary<string,Guid> ApplicationMap = new Dictionary<string, Guid>();
            Guid currentAppId;
            for (int i = 0; i < Math.Min(LogQueue.Current.Count, LogQueue.Current.MaxProcessedItems); i++)
            {

                 log = LogQueue.Current.Dequeue();
                if (log == null) continue;
                if (log.ApplicationKey == null) continue;

                if (!ApplicationMap.ContainsKey(log.ApplicationKey))
                {
                    var app = RepositoryContext.Current.Applications.GetByApplicationKey(log.ApplicationKey);
                    if (app == null) continue;
                    currentAppId = app.IdApplication;
                    ApplicationMap[log.ApplicationKey] = currentAppId;
                }
                else
                {
                    currentAppId = ApplicationMap[log.ApplicationKey];
                }

                
                logE = ConvertToLoEntities(log, currentAppId);
                result.Add(logE);

            }
            return result;
              
        }

        /// <summary>
        /// For performance issues is applicationId is passed, no query are done.
        /// </summary>
        /// <param name="log"></param>
        /// <param name="ApplicationId"></param>
        /// <returns></returns>
        public static LogEntity ConvertToLoEntities(LogMessage log, Guid? ApplicationId)
        {
            LogEntity ent = new LogEntity();
            
            ent.ApplictionId = ApplicationId ?? RepositoryContext.Current.Applications.GetByApplicationKey(log.ApplicationKey).IdApplication;
            ent.Level = log.Level;
            ent.Message = log.Message;
            ent.SourceDate = log.SourceDate;
            ent.UpdateDate = DateTime.Now;
            ent.CreateDate = DateTime.Now;
            return ent;
        }

        public void AppendLoadValue(long count, int maxQueueSize)
        {
            if (this.QueueLoad.Count > 100)
            {
                this.QueueLoad.RemoveAt(0);
            }

            this.QueueLoad.Add(new Classes.QueueLoad()
            {
                MaxSize = maxQueueSize,
                QueueSize = (int)count,
                Time = DateTime.Now
            });
        }

        public LogMessage Dequeue()
        {
            return queque.Dequeue();
        }

        private static LogQueue current = null;
        public static LogQueue Current
        {
            get
            {
                if (current == null)
                {
                    current = new LogQueue();
                }
                return current;
            }
        }

        public object LogHelper { get; private set; }
    }
}