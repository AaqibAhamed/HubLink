//******************************************************************************
// <copyright file="license.md" company="Wlog project  (https://github.com/arduosoft/wlog)">
// Copyright (c) 2016 Wlog project  (https://github.com/arduosoft/wlog)
// Wlog project is released under LGPL terms, see license.md file.
// </copyright>
// <author>Daniele Fontani, Emanuele Bucaelli</author>
// <autogenerated>true</autogenerated>
//******************************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using PagedList;
using Wlog.BLL.Entities;
using Wlog.Library.BLL.Classes;
using Wlog.Library.BLL.Enums;
using Wlog.Library.BLL.Interfaces;
using Wlog.DAL.NHibernate.Helpers;
using Wlog.Library.BLL.DataBase;
using Wlog.BLL.Classes;
using Wlog.Library.BLL.Index;
using Lucene.Net.Documents;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Lucene.Net.Search;
using System.Web;
using NLog;
using Wlog.Library.BLL.Exceptions;

namespace Wlog.Library.BLL.Reporitories
{
    /// <summary>
    /// Repo used to store logs
    /// </summary>
    public class LogRepository : EntityRepository<LogEntity>
    {
        public LogRepository()
        {

        }

        /// <summary>
        /// gived the count of logs by level
        /// </summary>
        /// <param name="level"></param>
        /// <returns></returns>
        public long CountByLevel(StandardLogLevels level)
        {
            logger.Debug("[repo] entering CountByLevel");
            return this.Count(p => level == StandardLogLevels.ALL_LEVELS || (p.Level != null && p.Level.ToLower().Contains(level.ToString())));
        }

        /// <summary>
        /// Save a log into database
        /// </summary>
        /// <param name="entToSave"></param>
        public override bool Save(LogEntity entToSave)
        {
            logger.Debug("[repo] entering Save");
            return Save(new List<LogEntity>(new LogEntity[] { entToSave }));
        }

        /// <summary>
        /// search in fulltext index and return a set of log
        /// </summary>
        /// <param name="applicationId"></param>
        /// <param name="logsSearchSettings"></param>
        /// <returns></returns>
        public IPagedList<LogEntity> SearchLogindex(Guid applicationId, LogsSearchSettings logsSearchSettings)
        {
            logger.Debug("[repo] entering SearchLogindex");

            var idx = RepositoryContext.Current.Index.GetByName("Logs", applicationId.ToString());

            try
            {
                IPagedList<Document> docs = idx.Query(logsSearchSettings.FullTextQuery.Trim(),
                    logsSearchSettings.OrderBy.ToString(),
                    SortField.STRING,
                    (logsSearchSettings.SortDirection == SortDirection.DESC),
                    (logsSearchSettings.PageNumber - 1) * logsSearchSettings.PageSize,
                    logsSearchSettings.PageSize,
                    LogsFields.Message.ToString());

                List<LogEntity> result = new List<LogEntity>();
                foreach (Document d in docs)
                {
                    result.Add(GetLogFromDoc(d));
                }
                return new StaticPagedList<LogEntity>(result, logsSearchSettings.PageNumber, logsSearchSettings.PageSize, docs.TotalItemCount);

            }
            catch (UnableToParseQuery err)
            {
                //TODO: [LOW] incapsulate response in wrapper with error and manage on the client side
                HttpContext.Current.Response.StatusCode = 500;
                HttpContext.Current.Response.StatusDescription = "Unable to parse Query";
                HttpContext.Current.Response.Write("Unable to parse Query");
                HttpContext.Current.Response.End();

            }
            return null;
        }

        public IPagedList<LogEntity> GetLogsForApplication(string userName, Guid applicationId, string sortOrder, string sortBy, string searchMessage, int pageSize, int pageNumber)
        {
            logger.Debug("[ConversionHelper]: GetLogs");

            List<Guid> allowedApps = RepositoryContext.Current.Applications.GetAppplicationsIdsByUsername(userName);

            if (!allowedApps.Contains(applicationId))
            {
                return new StaticPagedList<LogEntity>(new LogEntity[] { }, 0, 0, 0);
            }

            LogsSearchSettings settings = new LogsSearchSettings()
            {
                Applications = allowedApps,
                SearchMessage = searchMessage,
                PageNumber = pageNumber,
                PageSize = pageSize,
                FullTextQuery = searchMessage,
                SortDirection = (Library.BLL.Enums.SortDirection)Enum.Parse(typeof(Library.BLL.Enums.SortDirection), sortOrder.ToUpper()),
                OrderBy = sortBy
            };

            return SearchLogindex(applicationId, settings);
        }

        /// <summary>
        /// Convert lucene document to log Entity item
        /// </summary>
        /// <param name="d"></param>
        /// <returns></returns>
        private LogEntity GetLogFromDoc(Document d)
        {
            logger.Debug("[repo] entering GetLogFromDoc");

            return new LogEntity()
            {
                Level = d.GetField(LogsFields.Level.ToString()).StringValue,
                ApplictionId = new Guid(d.GetField(LogsFields.ApplicationId.ToString()).StringValue),
                Id = new Guid(d.GetField(LogsFields.Id.ToString()).StringValue),
                Message = d.GetField(LogsFields.Message.ToString()).StringValue,
                CreateDate = DateTools.StringToDate(d.GetField(LogsFields.CreateDate.ToString()).StringValue),
                SourceDate = DateTools.StringToDate(d.GetField(LogsFields.SourceDate.ToString()).StringValue),
                UpdateDate = DateTools.StringToDate(d.GetField(LogsFields.UpdateDate.ToString()).StringValue),
                Attributes = d.GetField(LogsFields.Attributes.ToString()).StringValue

            };

        }

        /// <summary>
        /// Search procedure on db data
        /// </summary>
        /// <param name="logsSearchSettings"></param>
        /// <returns></returns>
        public IPagedList<LogEntity> SearchLog(LogsSearchSettings logsSearchSettings)
        {
            logger.Debug("[repo] entering SearchLog");
            using (IUnitOfWork uow = BeginUnitOfWork())
            {
                uow.BeginTransaction();
                IQueryable<LogEntity> query = null;



                if (!String.IsNullOrWhiteSpace(logsSearchSettings.SearchMessage))
                {
                    query = uow.Query<LogEntity>().Where(p => logsSearchSettings.Applications.Contains(p.ApplictionId) &&
                            (logsSearchSettings.SearchMessage != null && p.Message != null && p.Message.ToLower().Contains(logsSearchSettings.SearchMessage)));

                }
                else
                {
                    query = uow.Query<LogEntity>().Where(x => logsSearchSettings.Applications.Contains(x.ApplictionId));
                }






                int count = query.Count();

                query = query.OrderByDescending(l => l.SourceDate);
                query = query.Skip((logsSearchSettings.PageNumber - 1) * logsSearchSettings.PageSize);
                query = query.Take(logsSearchSettings.PageSize);

                IPagedList<LogEntity> result = new StaticPagedList<LogEntity>(query.ToList(), logsSearchSettings.PageNumber, logsSearchSettings.PageSize, count);

                return result;
            }
        }

        /// <summary>
        /// sava a list of logs
        /// </summary>
        /// <param name="logs"></param>
        public bool Save(List<LogEntity> logs)
        {
            logger.Debug("[repo] entering Save");

            Dictionary<string, LuceneIndexManager> indexList = new Dictionary<string, LuceneIndexManager>();
            using (IUnitOfWork uow = BeginUnitOfWork())
            {
                uow.BeginTransaction();

                LogEntity log;
                for (int i = 0; i < logs.Count; i++)
                {
                    log = logs[i];


                    var idx = RepositoryContext.Current.Index.GetByName("Logs", log.ApplictionId.ToString());
                    idx.AddDocument(LogToDictionary(log));

                    uow.SaveOrUpdate(log);


                }

                uow.Commit();

                RepositoryContext.Current.Index.CommitAllIndexChanges();
            }

            return true;
        }

        /// <summary>
        /// Convert a log entity to a lucene document
        /// </summary>
        /// <param name="log"></param>
        /// <returns></returns>
        private Document LogToDictionary(LogEntity log)
        {
            logger.Debug("[repo] entering LogToDictionary");

            Document doc = new Document();

            doc.Add(new Field(LogsFields.Id.ToString(), log.Id.ToString(), Field.Store.YES, Field.Index.ANALYZED));
            doc.Add(new Field(LogsFields.Level.ToString(), log.Level, Field.Store.YES, Field.Index.ANALYZED));
            doc.Add(new Field(LogsFields.Message.ToString(), log.Message, Field.Store.YES, Field.Index.ANALYZED));


            doc.Add(new Field(LogsFields.SourceDate.ToString(), DateTools.DateToString(log.SourceDate, DateTools.Resolution.SECOND), Field.Store.YES, Field.Index.ANALYZED));
            doc.Add(new Field(LogsFields.UpdateDate.ToString(), DateTools.DateToString(log.UpdateDate, DateTools.Resolution.SECOND), Field.Store.YES, Field.Index.ANALYZED));
            doc.Add(new Field(LogsFields.CreateDate.ToString(), DateTools.DateToString(log.CreateDate, DateTools.Resolution.SECOND), Field.Store.YES, Field.Index.ANALYZED));

            doc.Add(new Field(LogsFields.ApplicationId.ToString(), log.ApplictionId.ToString(), Field.Store.YES, Field.Index.ANALYZED));
            doc.Add(new Field(LogsFields.Attributes.ToString(), log.Attributes ?? "", Field.Store.YES, Field.Index.NO));
            //doc.Add(new Field("Message", log.Attributes, Field.Store.YES, Field.Index.ANALYZED));

            if (!string.IsNullOrWhiteSpace(log.Attributes))
            {
                try
                {
                    JObject attrs = JObject.Parse(log.Attributes);
                    foreach (var attr in attrs)
                    {
                        if (doc.GetField(attr.Key) == null)
                        {
                            //TODO: [FEA] analize basing on attribute definition
                            doc.Add(new Field(attr.Key, attr.Value.ToString(), Field.Store.YES, Field.Index.ANALYZED));
                        }

                    }
                }
                catch
                {
                    //in case josn in not parsable                   
                }

                doc.Add(new Field("RawAttributess", log.Attributes, Field.Store.YES, Field.Index.ANALYZED));
            }
            return doc;
        }

        /// <summary>
        /// mode logs to bin
        /// </summary>
        /// <param name="logs"></param>
        /// <returns></returns>
        public bool MoveLogsToBin(List<LogEntity> logs)
        {

            logger.Debug("[repo] entering MoveLogsToBin");
            try
            {
                using (IUnitOfWork uow = BeginUnitOfWork())
                {
                    uow.BeginTransaction();

                    LogEntity log;// declare var ouside loop for better performance.
                    DeletedLogEntity deletedLog;
                    LuceneIndexManager idx;
                    for (int i = 0; i < logs.Count(); i++)
                    {
                        log = logs[i];
                        uow.Delete(log);



                        deletedLog = new DeletedLogEntity()
                        {
                            ApplictionId = log.ApplictionId,
                            DeletedOn = DateTime.UtcNow,
                            CreateDate = log.CreateDate,
                            Level = log.Level,
                            Message = log.Message,
                            SourceDate = log.SourceDate,
                            UpdateDate = log.UpdateDate,
                            LogId = log.Uid
                        };

                        uow.SaveOrUpdate(deletedLog);

                        // get index for Application
                        idx = RepositoryContext.Current.Index.GetByName("Logs", log.ApplictionId.ToString());
                        idx.RemoveDocument(LogsFields.Id.ToString(), log.Id);

                        if (i == logs.Count() - 1)
                        {
                            uow.Commit();
                            // I cant know how many index are affected by cleaning, I have to commit all                                                        
                            RepositoryContext.Current.Index.CommitAllIndexChanges();
                        }
                        else if (i % 100 == 0)
                        {
                            uow.Commit();
                            uow.BeginTransaction();
                            // I cant know how many index are affected by cleaning, I have to commit all                                                        
                            RepositoryContext.Current.Index.CommitAllIndexChanges();
                        }
                    }
                }

                return true;
            }
            catch (Exception ex)
            {
                logger.Error(ex);
                return false;
            }
        }

        /// <summary>
        /// Remove a log from database
        /// </summary>
        /// <param name="log"></param>
        public void RemoveLogEntity(LogEntity log)
        {
            logger.Debug("[repo] entering RemoveLogEntity");
            try
            {
                using (IUnitOfWork uow = BeginUnitOfWork())
                {
                    uow.BeginTransaction();
                    uow.Delete(log);
                    uow.Commit();
                }
            }
            catch (Exception ex)
            {
                logger.Error(ex);
            }
        }

        /// <summary>
        /// Get all long entries
        /// </summary>
        /// <returns></returns>
        public List<LogEntity> GetAllLogEntities()
        {
            //TODO: should this have paging input? all rows could be taken with a page of infinite size
            return this.QueryOver(null);
        }

        /// <summary>
        /// move logs to bin
        /// </summary>
        /// <param name="daysToKeep"></param>
        /// <param name="rowsToKeep"></param>
        /// <returns></returns>
        public bool ExecuteMoveToBinJob(int daysToKeep, int rowsToKeep)
        {
            logger.Debug("[repo] entering ExecuteMoveToBinJob");
            try
            {
                using (IUnitOfWork uow = BeginUnitOfWork())
                {
                    uow.BeginTransaction();


                    int batchSize = 1000;
                    //Delete all logs older than a date 

                    while (uow.Query<LogEntity>().Any(x => x.SourceDate < (DateTime.UtcNow.AddDays(-daysToKeep))))
                    {
                        //For performance issues, no matter about order
                        var logsBeforeDate = uow.Query<LogEntity>().Where(x => x.SourceDate < (DateTime.UtcNow.AddDays(-daysToKeep)))
                            .Take(batchSize).ToList();
                        MoveLogsToBin(logsBeforeDate);
                        //Repeat until all logs before date are deleted
                    }


                    while (uow.Query<LogEntity>().Count()> rowsToKeep)
                    {
                        //After I May need to remove addictional data to keep no more than x rows
                        var logsForBin = uow.Query<LogEntity>()
                            .OrderBy(x => x.SourceDate)
                            .Take(batchSize).ToList();                    


                        if (logsForBin.Any())
                        {
                            MoveLogsToBin(logsForBin);
                        }
                    }

                    return true;
                }
            }
            catch (Exception ex)
            {
                logger.Error(ex);
                return false;
            }
        }
    }
}